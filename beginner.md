# 読んだ書籍のまとめ

## オブジェクト指向でなぜつくるのか

メッセージパッシング:  
オブジェクトのメソッドを呼び出すこと。

グローバル変数はOOPで解決したかった、構造化プログラミングの最後の課題。
インスタンス変数はグローバル変数に近い存在。

インスタンス化≒メモリ領域の確保。

ポリモーフィズム:  
**共通メインルーチン**を作るための仕組み、とも言える。
構造化プログラミングにおける関数と対照的な立ち位置になる。

ガベージコレクションはOOPの範疇とも言える。

3つのメモリ領域を頭に入れておく。
特に、OOPにおいてメソッドコードは静的領域に、インスタンス変数などはヒープに格納されるイメージを持つこと
（共有できるものは静的領域で共有し、独立して管理すべきものはヒープで管理する）。

- 静的領域
  - アプリケーション開始時に確保する。
  - グローバル変数や実行コードを格納する。
  - アプリケーションでまとめて1つ。
- ヒープ領域
  - 開始時に一定領域を確保し、必要の都度アプリケーションに割り当てる。
  - 任意の情報を格納する（アプリケーションによる）。
  - システムまたはアプリケーションで1つ。
- スタック領域
  - LIFO
  - 呼び出したサブルーチンの引数、ローカル変数、戻り先などを格納する。
  - スレッドごとに1つ。

参照とポインタの違い:  
ポインタは加減算などの演算が可能だが、参照は変更が不可能という違いがあるらしいことは初めて知った。

**ハリウッドの原則:**  
フレームワークの仕組みの特徴を表した言葉。
基本的な処理はフレームワーク側で用意し、アプリケーション固有の処理はポリモーフィズムを利用して呼び出す。
アプリケーション固有「ではない（？）」処理については、継承の仕組みを利用して予めデフォルトの機能を用意しておく。  
ハリウッドでは、 "Don't call us, we will call you." という言葉で、
「必要なときはこちら（製作者側）から電話するから、（俳優側から）売り込みの電話はするな」という意味を表している言葉がある。
主体はフレームワーク側にあることを表す比喩となっている。

ユースケース:  
コンピュータが利用者に提供する機能を指す。
一応、ユースケース図もUMLに含まれる。

OOではないUML図:  
以下の3つが該当する。

- ユースケース図: コンピュータに任せる仕事の範囲を表現する
- アクティビティ図: 現実世界の仕事の流れを表現する
- ステートマシン図: 外部からのイベントによる状態変化を表現する

（ソフトウェア開発における）モデリングとは:  
UMLを使ってソフトウェアの機能や内部構造を2次元の図で表現することを指す。
以下の3工程からなる。

- 業務分析: 現実世界の様子をそのまま捉える
- 要件定義: コンピュータの性質を考慮して、肩代わりさせる仕事の範囲を決める
- **設計: ハードウェアの能力、OSやミドルウェアの特性、プログラミング言語の表現能力などを考慮して、ソフトウェアの構造を決める**

クラス図は、RDBの概念データモデルとも紐づく。

**凝集度（cohesion）を高める3つのコツ。**

- 一言で表現する名前をつける
- 秘密をたくさん作る
- 小さく作る

**アスペクト指向プログラミング（AOP）:**  
ロギングやトランザクション制御のように、アプリケーションのさまざまな部分に作用する共通な処理があり、
アスペクト指向ではこうした処理を「横断的関心（crosscutting concerns）」と呼ぶ。
OOPを初めとする現在一般的に普及しているプログラミング言語を使った場合、こうした「横断的関心」に相当するロジックは、プログラムのあちこちに分散してしまう。
アスペクト指向プログラミングは、こうした処理を「アスペクト」として独立して記述することで、ソフトウェアの柔軟性を向上させる「プログラミング技術」を指す。
具体的には、Pythonでよく観られるデコレータとかが該当する？

**コールバック関数は「お手軽なポリモーフィズム」と言える。**  
確かに、ファーストクラス関数によってGoFのデザインパターンの一部も置き換えることがデキることからもわかる。

オブジェクト指向言語では、変数と手続きをクラスに「まとめて、隠す」ことで、グローバル変数問題に対処する。
そしてこのクラスが、ソフトウェアを構成する基本部品となる。  
関数型言語では、変数の変更を禁止し、引数と戻り値を使って情報を受け渡すことで、グローバル変数問題に対処する。
**プログラムは関数のネットワークとして構成し、関数を基本的なソフトウェア部品として全体を組み上げる。**

## 現場で役立つシステム設計の原則

説明用の変数:  
式に名前をつけたもの。確かリファクタリングの一つの方法。

メソッドは短く、クラスは小さく:  
可読性が高く、変更しやすいコードの重要な原則。

**値オブジェクトは業務の用語そのもの。**

完全コンストラクタ:  
クラス設計のやり方の一つで、値オブジェクトを不変にするやり方。
以下のようにする。

- インスタンス変数はコンストラクタでオブジェクトの生成時に設定する
- インスタンス変数を変更するメソッド（setterメソッド）を作らない
- 別の値が必要であれば、別のインスタンス（オブジェクト）を作る

**ファーストクラスコレクション:**  
コレクション型のデータとロジックを特別扱いにして、コレクションを1つだけ持つ専用クラスを作るやり方のこと。
コレクションオブジェクトとも言う。
利用者側に便利なメソッドを準備することで、呼び出し側のコードをシンプルにする。
**中身の配列そのものを取り出せるような操作を実装してはならず、カプセル化を遵守すること。**
不変性を意識する。

区分ごとのクラス:  
業務アプリケーションでは、区分に応じた種類の様々なオブジェクトが登場するが、その場合にはポリモーフィズムを意識したい。
区分コードのif, switch-caseで分岐させるのではなく、区分ごとにクラスを作る。
また、全体を取りまとめるファクトリクラスに置いても、ハッシュマップを利用することで、生成時の区分値の条件分岐をなくすことができる。

クラス設計のポイント:  
**使う側のクラスのコードがシンプルになるように設計することが重要。**
オブジェクト指向らしいクラス設計、とも言えるが、そのために以下を意識すると良い。

- メソッドをロジックの置き場所にする
- ロジックを、データを持つクラスに移動する
- 使う側のクラスにロジックを書き始めたら設計を見直す
- メソッドを短くして、ロジックの移動をやりやすくする
- メソッドでは必ずインスタンス変数を使う
- クラスが肥大化したら小さく分ける

どれもリファクタリング本でも述べられていることで、**最初は雑でもいいからどんどん良くしていく**、という意識が必要になる。

凝集度とは:  
関連性の強いデータとロジックだけを集めたクラスを、凝集度が高いという。
凝集とは、「切っても切れない」関係のこと。

業務ロジック（ドメインオブジェクト）の作り方:  
小さいドメインオブジェクトから大きいドメインオブジェクトを作っていく。
**また、抽象的すぎるクラス名が現れたら注意が必要。**

ドメインモデルの関心の中心は「業務ロジック」:  
ドメインモデルは、業務ロジックの整理手法である。
業務データを判断・加工・計算するための業務ロジックを、データとひとまとまりにして「クラス」という単位で整理するのがオブジェクト指向の考え方である。
**関心の中心は業務ロジックであり、データではない。**

ドメインオブジェクトを機能の一部として設計しない:  
機能の分解構造や時間的な依存関係を持ち込まないようにする。
**特定の機能は処理の順番からは独立させて、単体で動作確認がデキる独立性の高い部品として開発する。**

**ヒト・モノ・コトのうち「コト」に注目する:**  
業務活動における現象のこと。
起きてほしいコトや起きてはいけないコトが存在する。
コトの基本属性として以下の3つがある。

- 対象: 何について発生した事象か
- 種別: どういう種類の事象か
- 時点: いつ起きた事象か

コトに注目することで次の関係も明らかになってくる。

- コトは、ヒトとモノとの関係として出現する（誰の何についての行動か）
- コトは、時間軸に沿って明確な前後関係を持つ

トランザクションスクリプトに陥る兆候:  
「ちょっとしたif文」を追加し始めたらやばい、リファクタリングが必要になり始める。
特に、アプリケーションレイヤ（サービスクラス）で起こりやすい。

サービスクラスをきれいに保つための方針:  
まず、サービスクラスは以下の理由からごちゃごちゃしやすくなる。

- ドメインオブジェクトが業務ロジックの置き場所として十分機能していない
- プレゼンテーション層の関心事に振り回される
- データベースの入出力の都合に引きずられる

よって、以下を徹底する。

- 業務ロジックは、サービスクラスに書かずにドメインオブジェクトに任せる（サービスクラスで判断・加工・計算しない）
- 画面の複雑さをそのままサービスクラスに持ち込まない
- データベースの入出力の都合からサービスクラスを独立させる

**また、サービスクラスも小さく分けることが大事。**

契約による設計:  
サービスを利用する側とサービスを提供する側戸で、サービス提供の約束事を決め、設計をシンプルに保つ技法を契約による設計と呼ぶ。
（おそらく、シンプルに保つのは呼び出し側のことだと思われる。）

防御的プログラミング:  
契約による設計と対照的な手法に当たる。
こちらは、サービスを利用する側も提供する側も、相手を信用せずに様々な検証を仕込むことを指す。

**シナリオクラス:**  
基本的なサービスクラスを組合せた複合サービスを提供するのがシナリオクラス。
シナリオクラスは次の2つの効果がある。

- アプリケーション機能の説明
- シナリオテストの単位

**リポジトリインターフェースはドメインモデル:**  
インターフェースに定義された振る舞いは、データベース操作ではなく業務の関心事を表すものであるから。

コトに注目するデータベース設計:  
業務アプリケーションでデータベースが重要なのは、コトを正しく記録し参照するため。

- 現実に起きたコトの記録
- 将来起きるコトの記録（約束の記録）

データベースには正しいデータのみを記録する。
それを担保するのが、データベース設計の基本目的である。
**NOT NULL制約、一意性制約、外部キー制約を使うことで、コトを正しく記録できる。**

イベントソーシング:  
コトの記録を基本にして、そこから派生するさまざまな情報を目的別に記録する方式のこと。

オブジェクトはオブジェクトらしく、テーブルはテーブルらしく:  
マッピングの記述の際は、フレームワークの都合によってドメインオブジェクトを汚さないように注意すること。

論理的な情報構造をドメインオブジェクトで表現する:  
UIとドメインオブジェクトの話。
「物理的なビュー」と「論理的なビュー」で分けて考えて、論理的なビューのみをドメインオブジェクトにもたせる。

エンティティを小さくするガイドライン:  
行数とかファイル数とかの話。
以下の指針は頭に入れておく。

- メソッドの行数: 3行を目標にする、1行でもよい
- クラスの行数: 50行を目標にする、100行以上は不可
- **パッケージのファイル数: 10ファイル以内**

