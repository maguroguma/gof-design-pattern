# Clean Architectureを理解する

## 資料集

- [クリーンアーキテクチャなんてものはない（クリーンアーキテクチャーの読み方）](https://yyyank.blogspot.com/2021/06/there-is-no-clean-architecture.html)
  - 以下の4つの「大事なこと」を留意しておきたい
    - 本を読んで大事なところを自分なりに理解して行動してみよう（どの本でも大事）
    - the クリーンアーキテクチャの一枚絵にこだわりすぎないようにしよう（ただの例として捉える）
    - DIPをやろう
    - 依存の方向は一方向にしよう
- [世界一わかりやすいClean Architecture](https://www.nuits.jp/entry/easiest-clean-architecture-2019-09)
  - 議論がとても丁寧だと感じた。まとめだけでも時々振り返るといいかもしれない。
  - やっぱり依存性逆転が主立っているんだなぁと思った。そこを中心とした議論も注目かも。
  - いくつか大事なコメントを引用。
    - この図で本当に大切なことは、依存性は外から中だけに向かっていなくてはいけない、というたった一点にあります。
    - 「依存性は、より上位レベルの方針にのみ向けよ」「制御の流れと依存方向は分離しコントロールせよ」「上位レベルとは相対的・再帰的であることに留意せよ」
- [「依存性逆転の原則」と「依存性の注入」を完全に理解した](https://qiita.com/uhooi/items/03ec6b7f0adc68610426)
  - 自分も思っていた疑問に回答が与えられた感じがしたので、この記事は好き。
  - ネイティブアプリ向けの言語が例に用いられているので、正直自分はとっつきにくいのが少し残念。
  - **以下の2つのコメントが大事！**
    - Bがインタフェースを提供し、Aがそれを実装してBに注入する場合、BはAに依存することなしにAを利用できますよね？普通はAを利用するためにはAに依存しないといけないところ（A←B）を、BはAに依存せずにAを利用し、逆にAがBのインタフェースを実装するためにBに依存する（A→B）のが「逆転」です。
      - （これをわかりにくくさせる原因ってレイヤードアーキテクチャのせいじゃないかと思った、あれって確かrepository interfaceがデータ永続層に配置されていた気がする。。）
    - 依存性を逆転させるには、制御の流れとしては上位にあるモジュールが、 **同じレイアに下位モジュールの抽象を作って、これに依存し、** 下位のモジュールは上位のレイア内で定義された抽象に依存し、その実装を作る必要があります。
- [良いコードとは何か](https://note.com/cyberz_cto/n/n26f535d6c575)
  - これも最後でClean Architectureを解説している。流石に正しい理解に基づいて解説されているように見える。
  - 凝集度と結合度の話がより具体的・詳細な粒度で述べられていて、自分の中でコードの良し悪しの根拠が持ちやすいのは大変良いと思った。
    - このあたりの雰囲気は、書籍「リファクタリング」を想起した。
  - 以下は引用。
    - 品質とスピードはトレードオフではなく、むしろ正の相関がある。品質を上げることで、コードの変更速度が上がり、手戻りが減り、学びのルールが早くなり、市場での競争力が上がります。
    - 品質を上げるため必要なのは、知識、経験です。
    - たとえ理解が不完全だとしても目の前の問題に対する現時点での理解でコードを書くことはいいことです。一方で、現時点での理解を可能な限り反映させることが重要です。すなわち、意図的な負債を紛れさせるなと。そうすることで、リファクタリングするときに、新しく学んだ理解に合わせて容易にリファクタリングすることができます。
      - これは最近仕事をしながら実際に感じたし、納得感がある。
    - とにかく関数を分ければ良い、というものではありません。関数に分けることで、たしかに凝集度を高めることはできますが、同時に認知負荷が多少なりとも上昇します。意味のわかる単位で区切ることが重要です。
    - Clean Architectureで主張されているのは、この2つのルールだけになります。 **1つ目は、レイヤーに分離し、関心事の分離を行う。2つ目は、それらの依存性は内側だけに向かっていなければいけないということです。** これらが守られているアーキテクチャが、クリーンなアーキテクチャとされています。
      - やはり。
    - 内側に近づくにつれ、ソフトウェアは抽象化され、一般的なものになる必要があります。
    - （内側から外側に情報を伝える）一つの方法は、RxやFlow等のストリームを使って、内側から外側にイベントを流す方法でしょう。MVVMのDataBindingもこれに当たります。この場合であっても、依存の方向は外側から内側のみになっています。
      - DIPだけが依存方向の制限方法だけだと思いこんでいたので、これは再認識しないといけない。確かに、慣れ親しんだVueのdata bindingもこれだった。
    - （境界線を超えるデータに関する注意事項として）2つ目は、 **内側が外側について知るようなデータを渡してはいけません。** 先程のUIProtocolも、UseCaseレイヤーの知識のみで作成する必要があります。
  - ただし、[ばんくしさんのこのツイート](https://twitter.com/vaaaaanquish/status/1498481409752637442)はちょっと大げさかなぁ、と思ってしまった。
    - 個人的には、これに匹敵する優れた文献や書籍も多くあると思った。また、鍛錬しないとちゃんと自分でかけるようにはならない、というのはいずれの文献も同様なはず。
- [システムの複雑さは](https://tech.uzabase.com/entry/2021/05/20/141950)
  - Clean Architectureを、より学術的に論じている（？）
  - 2006年の論文！
  - この論文がClojure作者のRich HickeyによるSimple Made Easyにつながっている模様。
    - 日本語の解説記事: https://boxofpapers.hatenablog.com/entry/simple_made_easy
      - これまで勉強してきた設計論に通ずる内容となっている（面白い）
- [状態、結合、複雑性、コード量の順に最適化する](https://ohbarye.hatenablog.jp/entry/2022/01/31/state-coupling-complexity-code)
  - ブログ主さんはout of the tar pitとリンクさせている
  - ブログ主さんがおっしゃっている通り、4つで覚えやすいのが素晴らしいと思った
  - 結合というとモジュール間の結合が思い浮かんでしまうが、そもそも単一責任の原則に反して複数の責務を負ったクラスなどは、外部モジュールとの見える結合・依存はないが、それ自身で密結合に陥っている
    - 記事最後の例を読んで、一瞬？となったので、↑は自分用メモ。

## 実際の書籍を読んで

> 設計とアーキテクチャについて最終的な定義をすることである。
> まずは、両者に違いがないことから主張したい。
> **何も違いはないのだ。**

> 下位レベルの詳細と上位レベルの構造は全体の設計の一部となる。

著者的には、 **設計とアーキテクチャは同じもの** らしい。

---

> ソフトウェアの1つ目の価値は「振る舞い」だ。

> ソフトウェアは「ソフト」になるように考案されたものだ。
> マシンの振る舞いを簡単に変更する手段になることを目的としたものである。
> マシンの振る舞いを簡単に変更したくないときは、それを「ハード」ウェアと読んだ。

> ソフトウェアはソフトでなければいけない。
> つまり、簡単に変更できなければいけない。

振る舞いを要求どおりに実装するだけではプロのプログラマではない。
**変更を容易にするようアーキテクチャを維持する必要がある、とのこと。**

著者はむしろ後者のほうが大事だと主張している。
**それができるのがアーキテクトである。**

---

> すべてのソースコードの依存関係の方向を絶対的に制御できる。
> 依存関係を制御の流れに合わせる必要はない。
> どのモジュールが呼び出しを行い、どのモジュールが呼び出されようとも、ソフトウェアアーキテクトはソースコードの依存関係をどの方向にも向ける事ができる。
> これはパワーだ！
> これがOOの提供するパワーである。
> これこそが本当のOOだ。
> 少なくともアーキテクトの観点からはそう言える。

> つまり、UIとデータベースをビジネスルールのプラグインにできるということだ。
> したがって、ビジネスルールのソースコードからUIやデータベースに言及することはない。

著者はこの直前に、OOは「危険な関数ポインタを使わなくても、抽象型によってポリモーフィズムが実現できることが重要」と説明しており、抽象型を用いた依存方向のコントロールを重要視している。
ただ、ちょっと大げさなような気もするが、それはこれから実践を重ねて学んでいきたい。

---

> モジュールはたったひとりのユーザやステークホルダーに対して責務を負うべきである。

> 変更を望む人たちをひとまとめにしたグループとして扱いたい。
> このグループのことをアクターと呼ぶことにしよう。

> モジュールはたったひとつのアクターに対して責務を負うべきである。

> 「モジュール」は、いくつかの関数やデータを纏めた凝集性のあるものだと考えよう

> 凝集性が、一つのアクターに対する責務を負うコードをまとめるフォースとなる。

> 単一責任の原則は、**アクターの異なるコードは分割するべき**という原則だ。

単一責任の原則に関する、このあたりの説明は結構読んで良かったという気がした。

---

> ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべきである、ということだ。

> **矢印の向かっている先が、自分自身を変更したときに影響を及ぼしたくないコンポーネントである。**
> 改めて言おう。
> コンポーネントAがコンポーネントBの変更から保護されるべきならば、コンポーネントBからコンポーネントAへ依存すべきである。

このあたりはオープン・クローズドの原則の説明。
オープン・クローズドの原則は、依存の矢印を考えたとき、変更がどう伝搬するか、を考えることっぽい。

---

> ソースコードの依存関係が（具象ではなく）抽象だけを参照しているもの。
> それが、最も柔軟なシステムである。
> これが「依存関係逆転の原則（DIP）」の伝えようとしていることである。

> **依存したくないのは、システム内の変化しやすい具象要素だ。**
> 開発中のモジュールや、頻繁に変更され続けているモジュールがその対象になる。

DIPは本書の大部分を占める。
「システム内の変化しやすい部分がどこか？」というのは、プログラミング中は常に意識したいところ。

---

> インターフェースは実装よりも変化しにくいということだ。

抽象に依存するのはいいことだ、と一般化することは果たしてできるのか？

---

> システムの中には、頻繁に変更すべきでないソフトウェアも含まれる。
> 上位レベルのアーキテクチャや方針を示すソフトウェアがそれに当たる。
> ビジネスやアーキテクチャに関する決定は、頻繁に変わってほしくはないものだ。
> したがって、そのシステムにおける上位レベルの方針をカプセル化したソフトウェアは、安定度の高いコンポーネントに配置しなければならない。
> 安定度の低いコンポーネントには、素早く簡単に変更できるようにしておきたいソフトウェアのみを含めるべきだ。

ここの「安定度」は、依存の矢印が入ってくるコンポーネントほど「高い」という指標のこと。
ちょっと言葉のイメージが結びつきづらい気がするが。

---

> **そもそもソフトウェアアーキテクトはプログラマである。**
> **プログラマを続けて置かなければいけない。**
> ソフトウェアアーキテクトはコードを書かず、より高いレベルの問題にフォーカスするものだ、という嘘を信じてはだめだ。
> そんなのはデタラメだ！
> ソフトウェアアーキテクトは最高のプログラマであり、継続してプログラミングの仕事を引き受けながら、生産性を最大化する設計にチームを導いていく。
> 他のプログラマほどコードを書かないかもしれないが、引き続きプログラミングの作業に関わっている。
> 自分で課題を経験していなければ、他のプログラマのために適切な仕事をすることなどできないからだ。

**「コードは書き続けなければならない。」**  
今後の自分のキャリアを考える上でも、このことは真であると仮定して考えていきたいと思う。

---

> **ソフトウェアシステムのアーキテクチャは、それを構築した人がシステムに与えた「形状」である。**
> その形状を生み出すためには、システムをコンポーネントに分割し、コンポーネントをうまく配置して、コンポーネントが相互に通信できるようにする必要がある。
> **アーキテクチャの形状の目的は、そこに含まれるソフトウェアシステムの開発・デプロイ・運用・保守を容易にすることである。**

「アーキテクチャとはなにか？」と聞かれたら、これを答えるのが良さそう。

---

> ソフトウェアアーキテクチャの目的は、システムを単一のアクションで簡単にデプロイできるようにすることである。

アーキテクチャとデプロイの容易性の間に関連があることは、もアーキテクチャについて考えるときに重要な観点となりそう。
デプロイについてはあまり知らないので、このあたりはこれから学んでいく必要がありそう。

---

> ソフトウェアシステムの全てにおいて、保守は最もコストがかかるものである。
> 永遠に続く新しい機能の登場と、避けられない欠陥や修正の繰り返しは、人的リソースを膨大に消費する。

> アーキテクチャを慎重に考え抜けば、これらのコストは大幅に低下する。

保守容易性は、アーキテクチャの寄与が大きい。
なお、著者は運用に関してはアーキテクチャが多少汚くてもなんとかなってしまうことも多い、と述べている。

---

> **あらゆるソフトウェアはシステムは、大きく2つの要素に分割できる。**
> **「方針」と「詳細」だ。**
> 方針の要素は、ビジネスのすべてのルールや手順を含んでいる。
> 方針には、システムの本当の価値がある。
> 詳細は、人間・その他のシステム・プログラマが、方針についてやり取りするために必要なものだが、方針の振る舞いに影響を与えるものではない。
> 詳細には、IOデバイス、データベース、ウェブシステム、サーバ、フレームワーク、通信プロトコルなどが含まれる。
> **アーキテクトの目的は、方針とは無関係に詳細を決めながら、方針をシステムの最も重要な要素と認識するシステムの形状を作ることである。**
> こうすることで、詳細の決定を延期や留保することができる。

まず、DDDとかを考えると複雑で頭がこんがらがってしまいそうなところを、方針と詳細と二分してしまうのは、正直言ってありがたい。
このぐらいシンプルじゃないと自分は実践しようという気になれない。

なお、最後の一文は、「フレームワーク決定の延期とか実際に出きるの？」という感じで、訳者にも疑問視されていた。

---

> 優れたアーキテクチャは以下のことをサポートしなければいけない。
> システムのユースケース、システムの運用、システムの開発、システムのデプロイ。

> 「ユースケース」とは、アーキテクチャがシステムの意図をサポートしなければいけないことを意味している。

> **アーキテクチャが振る舞いをサポートするために最も重要なことは、アーキテクチャレベルでシステムの意図がわかるように、振る舞いを明らかにすることである。**

ユースケースという単語は、結構曖昧な理解なので、これを機に自分の中で明文化しておきたい。

---

> 異なる理由で変更されるものとはなにか？
> 明らかなものがいくつかある。
> 例えば、ユーザインターフェースを変更する理由は、ビジネスルールを変更する理由とは関係がない。
> **だが、ユースケースにはその両方の要素がある。**
> **優れたアーキテクトならば、ユースケースのUI部分とビジネスルールの部分を分離したいと思うはずだ。**
> そうすれば、ユースケースは明確にしたままで、それぞれの部分を独立して変更できるようになる。

> このように、システムは切り離された水平レイヤー（たとえば、UI、アプリケーション特有のビジネスルール、アプリケーションに依存しないビジネスルール、データベースなど）で分割されていることがわかる。

> ほかに異なる理由で変更されるものはあるだろうか？
> ユースケースそのものがそうだ！
> 注文入力システムに注文を追加するユースケースは、注文を削除するユースケースと比べると、明らかに異なる頻度と理由で変更される。
> **ユースケースはシステムを分割する自然な方法である。**

ユースケースを考えるとき「変更の頻度」という観点を持つと良いかもしれない。

---

> 気をつけてほしい。
> **反射的に重複を排除する罪を犯してはいけない。**
> **その重複が本物かどうかを見極めるべきだ。**

DRYは大事だが、うかつにユースケースを同じものとして扱うと大変なことになる（すでに経験している気がする）。

---

> ソフトウェアアーキテクチャとは、境界線を引く技芸である。
> これを私は「バウンダリー」と呼んでいる。
> **ソフトウェアの要素を分離し、お互いのことがわからないように制限するというものである。**

ここからは「境界」の話。

---

> 境界線は「重要なもの」と「重要ではないもの」の間に引く。
> GUIはビジネスルールにとって重要ではないので、その間に境界線を引く。
> データベースはGUIにとって重要ではないので、その間に境界線を引く。
> データベースはビジネスルールにとって重要ではないので、その間に境界線を引く。

> ビジネスルールが知る必要があるのは、データを取得・保存する機能が存在するということだけだ。
> したがって、データベースはインターフェイスの裏側に置くことができる。

DIPの話もそうだが、ここではrepositoryインターフェースはどのレイヤに属するのか？という自分が抱いた疑問に自然な回答を与えてくれた（正直、これだけでもこの本に価値があった、と思う）。

---

> 開発者と顧客は、システムについて見誤る事が多い。
> **GUIを見て、GUIがシステムだと思っている。**
> **GUIの観点からシステムを定義しているので、GUIはすぐに動作しなければいけないものだと思っている。**
> 重要な原則を認識していないのだ。
> **その原則とは「IOは無関係」である。**

> インターフェースの背後には、それを動かすモデル（洗練されたデータ構造と機能）があることを忘れてしまう。
> さらに重要なのは、そうしたモデルにはインターフェースは必要ないということだ。
> 画面にゲームを表示しなくても、ゲームのイベントをモデリングして、その責務を実行できる。
> **インターフェースはモデルにとって重要ではない。**
> **そしてモデルはビジネスルールである。**

nrsさんの本などでも説明されていたこと。
スクラムとかでは、こういうモデルのテストだけ見せて納得させたりするんだろうか？

---

> 実際、ソフトウェア開発技術の歴史は、いかに都合よくプラグインを作成するかの物語だ。
> プラグインによって、スケーラブルで保守可能なシステムアーキテクチャを確立するのである。
> コアとなるビジネスルールは、選択式またはその他の形式で実装されたコンポーネントから分離・独立している。

> **システムをプラグインアーキテクチャにしておくと、変更の影響を伝搬させないファイアウォールを構築できる。**
> **GUIをビジネスルールにプラグインしている場合、GUIの変更はビジネスルールに影響を与えない。**
> 境界線は変更の軸があるところに引く。
> 境界線を挟んだコンポーネントは、それぞれ変更の頻度や理由が違っているのである。

> これも単一責任の原則である。
> 単一責任の原則はどこに境界線を引けばいいかを教えてくれる。

「プラグインアーキテクチャ」という単語は初めて聞いた。
ちゃんと設計すれば、UIやDBはプラグインである、という見方もできる。

---

> 上位レベルのサービスのソースコードには、下位レベルのサービスの物理的な情報（たとえば、URIなど）を含めてはいけない。

コードを書いているときの「怪しい香り」の例といえそう。

---

> どのような場合でも、下位レベルのコンポーネントが上位レベルのコンポーネントに依存するように設計する。

> **「レベル」の厳密な定義は、「入力と出力からの距離」である。**

> 入力と出力を管理する方針は、システムの中で最下位レベルの方針になる。

**「方針とレベル」の話。**

---

> データフローとソースコードの依存性は、必ずしも同じ方向を指しているとは限らない。
> これもまたソフトウェアアーキテクチャの技芸のひとつである。
> **ソースコードの依存性はデータフローから切り離し、レベルと結びつけるべきである。**

普通に何も考えずにプログラムを書くと、当然処理の流れと依存性の方向が一致してしまうと思う。
ここを自制して、丁寧に依存の方向をコントロールするのがアーキテクトへの第一歩だと理解した。

そういう意味でも、やはり「（入出力からの距離という意味での）レベル」は常に念頭においておく必要がある。

---

> 上位レベルの方針（入出力から遠い方針）は、下位レベルの方針よりも変更の頻度が低く、変更の理由が重要である。
> 下位レベルの方針（入出力に近い方針）は、変更の頻度が高く、緊急性は高いものの、変更の理由はさほど重要ではない。

> システムの下位レベルに重要ではないが緊急の変更があったとしても、重要な上位レベルにほとんど、あるいはまったく影響を与えることがない。

依存の辺の始点に位置する下位レベルは、ガシガシ変更できるようにする。

※事業会社だと上位レベルの変更って結構頻繁に起こる気がする。。自分が体験してきたレベルは別に頻繁でもなんでもないのだろうか？

---

> **ビジネスルールとは、ビジネスマネーを生み出したり節約したりするルールや手続きのことだ。**
> **厳密に言えば、コンピュータで実装されているかどうかに関わらず、ビジネスマネーを生み出したり節約したりするルールのことだ。**
> 手動で実行されたとしても、お金を生み出したり節約したりすることはできる。

「ビジネスルール」って変な言葉だなっていつも思っているが、ビジネスマネーというのを考えるとこの名前しかありえないような気がしてくる。
でもやっぱり、ゲームとで使うのは変な感じがするから、もっといい定義はないものだろうか？

ともかく、このあたりに書かれていることはとても重要。

---

> こうしたルールのことを最重要ビジネスルールと呼ぶ。
> ビジネスにとって欠かせないものであり、システムが自動化されていなくても存在するからだ。
> 最重要ビジネスルールには、いくつかのデータが必要になる。
> 例えば、ローンであれば、貸付金残高、金利、支払いスケジュールなどが必要になる。
> こうしたデータのことを **最重要ビジネスデータ** と呼ぶ。
> システムが自動化されていなくても存在するデータだからだ。
> 最重要ビジネスルールと最重要ビジネスデータは密接に結びついているため、オブジェクトの有力な候補になる。
> **こうしたオブジェクトのことをエンティティと呼びたい。**

DDDでは、エンティティというと識別子を持っていてそれによって同一性が定義されるもの、というものだったと思うが、それとは異なった定義がここではされている。

---

> **エンティティとはコンピュータシステムの内部にあるオブジェクトであり、最重要ビジネスデータを操作する最重要ビジネスルールをいくつか含んだものである。**
> エンティティオブジェクトには、最重要ビジネスデータかそれらのデータへの簡単なアクセス手段が含まれる。
> エンティティのインターフェースは、そうしたデータを操作する最重要ビジネスルールを実装した関数で構成されている。

> **エンティティは、データベース、ユーザインターフェース、サードパティ製のフレームワークについて、何も気にする必要はない。**
> **システムがどのようなものであっても、データがどのように保存されていても、コンピュータがどのように配置されていても、エンティティはあらゆるシステムのビジネスに役立つ。**
> **エンティティはビジネスであり、それ以外の何者でもない。**

定義はDDDと違っても、ドメインオブジェクトと同じく、上位レベルのものである、という認識は同じらしい。

---

> エンティティを作成するのにオブジェクト指向言語は不要である。
> **最重要ビジネスデータと最重要ビジネスルールを同じソフトウェアモジュールにまとめるだけでいい。**

ビジネスにとって大事なデータと振る舞いがモジュールにまとまっている、ということがエンティティたらしめる条件らしい。
ということは、関数型言語でもモジュール内にデータ型と処理を行う関数がまとまっていれば、それはエンティティである、ということだろうか。

---

> ビジネスルールはエンティティほど純粋なものばかりではない。
> **自動化されたシステムを定義・制限することによって、ビジネスのお金を生み出したり節約したりするビジネスルールもある。**
> こうしたルールは手動の環境では使用されない。
> 自動化されたシステムの一部としてのみ意味があるからだ。

> **これは、ユースケースと呼ばれるものだ。**
> **ユースケースとは、自動化されたシステムを使用する方法を記述したものである。**
> **ユーザから提供された入力、ユーザに戻す出力、出力を生成する処理ステップなどを規定している。**
> **エンティティに含まれる最重要ビジネスルールとは違い、ユースケースはアプリケーション固有のビジネスルールを記述している。**

「ユースケースってどういうものだろう？」とずっと思ってきたが、ここで説明された定義が最も具体的でわかりやすいように思える。
「自動化したシステム、入出力、処理ステップの規定」あたりがキーワードになりそう（この3つの言葉を含めて説明せよ、的な）。

---

> **ユースケースには、エンティティの最重要ビジネスルールをいつ・どのように呼び出すかを規定したルールが含まれている。**
> **ユースケースはエンティティのダンスを制御しているのである。**
> **ユースケースは、ユーザインターフェースについては記述していない。**
> **インターフェースからやってくるデータとそこから出ていくデータを略式で規定しているだけである。**
> ユースケースを見ただけでは、そのアプリケーションがウェブなのか、シッククライアントなのか、コンソールなのか、純粋なサービスなのかを判断することは不可能である。

> **ユースケースはシステムのユーザに対する見た目を記述するものではない。**
> ユーザとエンティティのインタラクションを支配するアプリケーション固有のルールを記述したものである。
> データがどのようにシステムに入出力されるかは、ユースケースとは無関係だ。

> **ユースケースはオブジェクトである。**
> アプリケーション固有のビジネスルールを実装した関数を1つ以上持っている。
> また、入力データ、出力データ、それらがやり取りする適切なエンティティへの参照といった、データ要素を持っている。

> では、なぜエンティティが上位レベルで、ユースケースが下位レベルなのだろうか？
> ユースケースはアプリケーション固有なので、システムの入力と出力に近い。
> エンティティは複数のアプリケーションで使用できるように一般化されているので、システムの入力と出力から遠く離れている。
> したがって、ユースケースはエンティティに依存し、エンティティはユースケースに依存していないのである。

このあたりもユースケースの説明になる。
ただ「ユースケースはオブジェクトである」というのはそうなの？と思った。
でも確かに、関数でもぴったりだと思ったが、入出力データやエンティティの参照を必要とする、という観点からするとオブジェクトとして実装するほうが楽かもしれない。

※あとのクリーンアーキテクチャの章で、「データ構造と関数でも構わない」と書かれていた。

---

> **ユースケースクラスは、入力としてシンプルなリクエストデータ構造を受け取り、出力としてシンプルなレスポンスデータ構造を戻す。**
> **これらのデータ構造は何にも依存していない。**
> HttpRequestやHttpResponseといった、標準的なフレームワークのインターフェースから派生したものでもない。
> ウェブのことは何も知らないし、他のユーザインターフェースに関することも把握していない。

> **これらのデータ構造にエンティティオブジェクトへの参照を含めたいと思うかもしれない。**
> エンティティとリクエストとレスポンスのモデルは多くのデータを共有しているので、合理的な判断だと考えられるのだろう。
> **だが、この誘惑に負けてはいけない！**

ユースケースの入出力データというのは、ちょっと立ち止まって考える必要があるかもしれない。
依存方向だけ考えると、エンティティとかの上位レベルのデータを返してもルール違反にはならなそうだが、それはよくないとのこと。
単一責任の原則に反しているから、とのことだが、ちょっとまだピンと来ていない。

---

> では、あなたのアプリケーションのアーキテクチャは何と叫んでいるだろうか？
> 最上位レベルのディレクトリ校オズと最上位レベルのパッケージのソースファイルは、「ヘルスケアシステム」「会計システム」「在庫管理システム」と叫んでいるだろうか？
> それとも「Rails」「Spring/Hibernate」「ASP」と叫んでいるだろうか？

「叫ぶアーキテクチャ」という名前の章で、非常に印象的。

---

> ソフトウェアアプリケーションのアーキテクチャもアプリケーションのユースケースについて叫ぶべきである。

> アーキテクチャはフレームワークに関するものではない（そうあるべきではない）。
> アーキテクチャはフレームワークから提供されるものではない。
> フレームワークは使用するツールであり、アーキテクチャが従うものではない。

> ウェブは提供の仕組み（IOデバイス）であり、アプリケーションアーキテクチャもウェブのことをそのように扱うべきである。
> アプリケーションがウェブで提供されている事実は詳細であり、システム構造を支配するものではない。

> フレームワークにアーキテクチャを乗っ取られないように、戦略をうまく策定しよう。

> **システムアーキテクチャがユースケースをサポートするものであり、フレームワークから少し距離をおいたものになっていれば、フレームワークを使うことなく、すべてのユースケースのユニットテストを実行できるはずだ。**
> テストを実行するためにウェブサーバを起動する必要はない。
> テストを実行するためにデータベースに接続する必要はない。

この部分のメリットを得るためには、アーキテクチャにユースケースについて叫ばせるべきだと思うが、どこまで頑張る必要があるだろうか？

---

> 円の外側は仕組み。
> 内側は方針である。
> このアーキテクチャを動作させる最も重要なルールは、依存性のルールである。
> ソースコードの依存性は、内側（上位レベルの方針）だけに向かっていなければいけない。

ここからいよいよ、書籍名であるクリーンアーキテクチャの章となる。
エンティティ→ユースケースときて、その後外側に来るものがしばしば議論（炎上？）している気がする。

あの例の円の画像は[ここ](https://blog.tai2.net/the_clean_architecture.html)などを参照。

---

> **インターフェースアダプターのレイヤーのソフトウェアは、ユースケースやエンティティに便利なフォーマットから、データベースやウェブなどの外部エージェントに便利なフォーマットにデータを変換するアダプターである。**

> 同様に、このレイヤーでは、エンティティやユースケースに便利な形式から、永続フレームワーク（つまりデータベース）に便利な形式にデータを変換する。

> また、このレイヤーには、外部サービスなどの外部の形式から、ユースケースやエンティティが使用する内部の形式にデータを変換するアダプターも含まれる。

「インターフェースアダプター」というレイヤには、コントローラー（ウェブ、デバイスなどのIO）、ゲートウェイ（DB）、プレゼンター（UI）といったものが含まれる。

とあるブログ記事はこのレイヤについて批判していたと思う。
確かに、DIPによって依存性の方向はコントロールできるけど、「データベースに便利な形式に変換するレイヤ」ということは、そのレイヤは外のデータベースについて知っている、知らなければそのような変換はできない、といえるはず。
そうすると隠れた内側から外側への依存があるはずで、例えばデータベースを別のものに変えたら、このレイヤも影響を受けるはず。
という批判の理屈だったと理解している。

---

> フレームワークとドライバ
> 通常、このレイヤにはコードをあまり書かない。
> 書くとしても、円の次の内側とやり取りするグルーコードくらいである。

インターフェースアダプターのレイヤを設けないと、必ずしもコード量は少なくならない気がする？
いやでもDBとかは具体的なクエリとかを書く必要がありそうだし、コード量はそこそこ多くならざるを得ない気がするが？

---

> **境界線を超えるデータは、単純なデータ構造で構成されている。**
> 好みに応じて、構造体やデータ転送オブジェクトを使うこともできる。
> 単なる関数呼び出しの引数にすることもできる。
> ハッシュマップに詰め込んだり、オブジェクトにしたりすることもできる。
> 境界線を超えて渡すのは、独立した単純なデータ構造であることが重要だ。
> **エンティティオブジェクトやデータベースの行をそのまま渡すようなズルはしたくない。**
> また、依存性のルールに違反するような依存性をデータ構造に持たせたくはない。

> **行構造を円の内側の境界線を超えて渡したくはない。**
> **渡してしまうと、円の内側が外側について知ることになるため、依存性のルールに違反することになる。**
> **したがって、境界線を超えてデータを渡すときは、常に内側の円にとって便利な形式にする。**

境界線を超えるときのデータについては中止する必要がある。
が、実際のところこのあたりは実践してみないとわからないこと多そうなので、練習あるのみ。

---

> プレゼンターは、Humble Objectパターンの一種

> Humble Objectパターンは、ユニットテストを実行する人が、テストしにくいふるまいとテストしやすいふるまいを分離するために生み出されたデザインパターンである。
> アイデアは非常にシンプルだ。
> 振る舞いを2つのモジュールまたはクラスに分割するだけである。
> **一つのモジュールは「Humble（控えめ）」で、ここにはテストが難しいふるまいのみが含まれる。**
> もう一つのモジュールには、Humble Objectから取り除かれたテストしやすいふるまいが含まれる。

> **Humble Objectパターンを使えば、2種類の振る舞いをPresenterとViewの2つのクラスに分けられる。**

僕の大好きなHumble Objectパターンの話。
脚注では、2007年の「xUnit Test Patterns」という本が初出っぽい？

「Vueのバインドするデータと振る舞いを集めたクラスはPresenterに該当する」、というのが今の所の自分の理解。

---

> Viewは、Humble Objectである。
> こちらはテストが難しい。
> したがって、このオブジェクトのコードはできるだけシンプルに保っておく。
> GUIにデータを移動するが、そのデータを処理することはない。
> Presenterは、テスト可能なオブジェクトである。

> Presenterはそのデータを適切な文字列にフォーマットして、Viewから発見できるViewModelというシンプルなデータ構造に配置する。

> Viewがやるべきことは、ViewModelからデータを読み込み、画面に移動すること以外に残されていない。
> だからこそ、ViewはHumbleなのである。

Vueなんかでいうと、tsファイルに切り分けたTypeScriptオンリーな関数やクラスなどのモジュールがPresenterと言えそう。
ViewModelは単一ファイルコンポーネントのscriptセクションで記述される部分で、Viewが宣言的な制御構文を含むtemplateセクションで記述される部分、という感じだと思う。

---

> テスト容易性が、優れたアーキテクチャの特性であることは、これまでずっと知られてきたことだ。
> Humble Objectパターンはその好例である。
> 振る舞いをテストしやすい部分とテストしにくい部分に分割することが、アーキテクチャの境界の定義につながるからだ。
> PresenterとViewもそうした境界のひとつだ。

「テスト容易性」というのは重要な特性である。

---

> ユースケースインタラクターとデータベースの間にあるのが「データベースゲートウェイ」である。
> このゲートウェイは、アプリケーションがデータベースに対して実行する作成・読み取り・更新・削除のメソッドを含んだ**ポリモーフィックインターフェースである。**

データベースゲートウェイというのは、2003年頃に出た別の文献で登場しているらしい。
「インターフェースである」ということに注意。
このレイヤーも、やはり抽象度としては高く、後述されるようにテストは可能なものである。

---

> ユースケースのレイヤでSQLの使用を許可しなかったことを思い出してほしい。
> その代わり、ゲートウェイにメソッドを用意して使うようにした。
> **ゲートウェイはデータベースのレイヤにあるクラスで実装する。**
> **この実装は、Humble Objectである。**

> **一方、インタラクターはHumbleではない。**
> アプリケーション固有のビジネスルールをカプセル化しているからだ。
> Humbleではないが、インタラクターはテスト可能である。
> **ゲートウェイを適切なスタブやテストダブルに置き換えることができるからだ。**

あの同心円の3層目はわかりにくいが、Humble Objectパターンが背後に有ることを意識すると、理解しやすいかもしれない。
ユースケースよりは外側で詳細に近いが、なおHumbleではなく、テスタブルであるべし、という感じ。

---

> ORMは「データマッパー」と呼ぶほうが適切だ。
> リレーショナルデータベーステーブルから読み取ったデータをデータ構造に詰め込むからだ。
> では、ORMシステムはどこに属するのだろうか？
> もちろんデータベースのレイヤだ。
> 実際、ORMはゲートウェイインターフェースとデータベースの間にHumble Objectの境界を作るものである。

「オブジェクトは振る舞いを含むものなので、単なるデータの集まり（データ構造）ではない」という主張を踏まえて、ORMの誤解を解こうとしている？
ORM自体に自分はまだ不慣れなので、ここは「ふーん」ぐらいで済ませておく。

---

> すべてのシステムには、その他のコンポーネントを作成・調整・監督するコンポーネントが少なくとも1つ存在する。
> 私はこのコンポーネントをMainと呼んでいる。

> 「メインコンポーネント」という名前の章が始まる。

> **Mainコンポーネントは、究極的な詳細（最下位レベルの方針）である。**

> オペレーティング・システム以外に、このコンポーネントに依存しているものはない。
> **FactoryやStrategyなどのグローバルな要素を作成し、システムの上位の抽象部分に制御を渡すことが、このコンポーネントの仕事になる。**

> Mainは、汚れ仕事が最も似合うコンポーネントだ。

> Mainをアプリケーションのプラグインと考えよう。
> 初期状態や構成を設定して、外部リソースを集め、アプリケーションの上位レベルの方針に制御を渡すプラグインである。
> **プラグインなので、アプリケーションの設定ごとに複数のMainコンポーネントを持つこともできる。**
> **たとえば、開発用、テスト用、本番用のMainを用意することもできる。**
> あるいは、デプロイする国別、権限別、顧客別に用意することもできるだろう。
> Mainをアーキテクチャの境界の背後にあるプラグインとして考えると、設定の問題はもっと解決しやすくなるはずだ。

mainというものを「アプリケーションのエントリポイント」以外の見方をしたことがなかったが、実際このようなメンタルモデルを持っておくと、役に立つことも多くありそうだと思った。

---

> **そうだ、テストはシステムの一部だ。**
> システムの他の部分と同様に、テストもアーキテクチャに関与している。

なにやらまた思想の強そうな章が始まった。

---

> テストは、その性質上、依存性のルールに従う。
> テストは、非常に詳細で具体的であり、テストするコードに対して常に依存している。
> **実際、テストはアーキテクチャの円の最も外側にあると考えることができる。**
> **システムに含まれるものはテストに依存しておらず、常にテストのほうがシステムのコンポーネントに依存している。**
> **テストも独立してデプロイ可能である。**
> 殆どの場合、プロダクションシステムではなく、テストシステムにデプロイされる。
> したがって、独立したデプロイが不要なシステムであっても、テストは依然として独立してデプロイできる。

> テストは最も独立したシステムコンポーネントである。
> システムの運用には不要だ。

> テストの役割は運用ではなく、開発をサポートすることだ。
> それでも、ほかと同じシステムコンポーネントである。
> 実際、多くの点において、その他のすべてのシステムコンポーネントが従うべきモデルを表している。

なんとなく言っていることは正しいと思えるし、面白い見方だと思えるが、このような見方が実際に「どのように開発をサポートするのか？」は、まだよくわからない。

---

> **脆弱なテストは、システムを硬直化させるという悪影響を及ぼす。**
> **システムを少し変更しただけで大量のテストが失敗するとなると、開発者は変更するのをためらうだろう。**

> **変化しやすいものに依存しない、だ。**

> したがって、GUIを使用しなくてもビジネスルールのテストができるように、システムとテストを設計しなければいけない。

このあたりは、何でもかんでもテストしてしまう、というアンチパターンに陥らないために重要だと思う。
Viewとかのテストは、やるとしても最後にやりたい。

※このあと「テストAPI」というものが突然登場するが、正直読んでも具体的にどういうものなのかイメージできなかったので、今は飛ばしてしまう。

---

> アーキテクチャ的にパフォーマンスは気になるところではないかって？
> もちろん気になる。
> だが、データストレージのパフォーマンスについては、ビジネスルールと切り離して考えられる。
> データストアからのデータの出し入れを高速に実行する必要があるだろうが、それは下位レベルの関心事である。
> そのことに対応するには、下位レベルのデータアクセスの仕組みを使うことになる。
> そしてそれは、システムの全体的なアーキテクチャとは関係のないものだ。

「データベースは詳細」という章の記述。

---

> マーケティングの奴らはいつも、ビジネスルールとUIを一体化したがるのだから。

> 結論はシンプルだ。
> GUIは詳細である。
> ウェブはGUIである。
> したがって、ウェブは詳細である。

> ウェブは入出力デバイスの一種である。
> 我々は、デバイスに依存しないアプリケーションを書くことを60年代に学んだ。
> その考えは今も生きている。
> ウェブだって例外ではない。

「ウェブは詳細」という章の記述。
そうなのよねぇ。

---

> フレームワークはアーキテクチャではない。
> なかにはそうであろうとしているものもあるが、それでもやはりアーキテクチャではない。

「フレームワークは詳細」という章の記述。

---

> おそらく作者たちは、フレームワークのクラスの派生クラスを作り、その機能をビジネスオブジェクトに組み込むことを推奨するだろう。
> アプリケーションとフレームワークを可能な限り結合させようとするのである。

> 一方的な結婚だ。
> すべてのリスクと負担を背負うのは我々であり、フレームワークの作者は何一つ背負うことはない。

> フレームワークの作者は、円の最も内側にフレームワークを結合させたがっている。
> 一度入り込んでしまえば、それを取り外すことはできなくなる。

> アプリケーションを作り始めた頃は、フレームワークが助けになってくれるだろう。
> しかし、プロダクトが成長するにつれて、フレームワークの提供する機能では手に負えなくなってくる。
> 結婚指輪をはめたままでいると、フレームワークに邪魔されてばかりいる自分に気づくだろう。

印象的な比喩ゆえに、注意喚起としては良いと思う。
ただ、若干偏執的な感じもする。
いずれにせよ、フレームワークを使うときは留意しつつ注意したい。

---

> フレームワークを使うことは問題ない。
> ただし、結合しないことが大切だ。
> フレームワークとは一定の距離を保つこと。
> **フレームワークは、アーキテクチャの円の外側にあるものとして扱おう。**
> 円の内側に組み込んではいけない。

> フレームワークの基底クラスからビジネスオブジェクトを派生させること求められても、断ること。
> その変わり、プロキシを用意して、そのプロキシを含めたコンポーネントをビジネスルールにプラグインすればいい。
> フレームワークをコアのコードに混ぜないこと。
> フレームワークはコンポーネントにまとめて、コアのコードにプラグインしよう。
> そうすることで、依存性のルールを守れるはずだ。

> ビジネスオブジェクトがSpringについて知るべきではないのだ。
> そうではなく、Springを使ってMainコンポーネントに依存性を注入しよう。
> MainコンポーネントがSpringについて知っていることはなんの問題もない。
> Mainはアーキテクチャのなかで最下位レベルのコンポーネントだからだ。

より具体的な注意喚起。

---

ここからは「書き残したこと」ということで、アンクルボブの記述・主張ではない？

> レイヤードアーキテクチャはビジネスドメインに関して何も叫ばない。
> 全く異なる2つのビジネスドメインのコードをそれぞれレイヤードアーキテクチャにして並べてみると、気味が悪いほどそっくりになる。
> ウェブ、サービス、そしてリポジトリだ。

確かに、言われてみればそうだ。

> いくらうまい設計をしても、その実装方法の複雑さを考慮しなければ、あっという間に設計が崩れてしまう。

> **理想に走りすぎてもいけない。**
> チームの規模やメンバーのスキルやソリューションの複雑さ、そして時間と予算の制約などを考慮しよう。
> 選んだアーキテクチャスタイルを守らせるためにコンパイラが使えるかどうかを検討して、データモデルなどの他の領域と結合してしまわないように注意しよう。
> 悪魔は実装の詳細に宿るのだ。

最後のこの部分は実業務を考える上でとても大事だと思う。
どこかで折り合いを付ける必要は絶対に出てくるはず。

---

## 補足

### [フロントエンドのデザインパターン: コンテナ・プレゼンテーションパターン](https://zenn.dev/morinokami/books/learning-patterns-1/viewer/presentational-container-pattern)

Clean Architecture内で言及されている、Presenterに該当しているようにも見えるが、違うもののようにも見える。

コンテナコンポーネントとプレゼンテーションコンポーネントの2つがあり、包含関係はコンテナが後者を含んでいる形（コンテナという言葉と齟齬がない）。
プレゼンテーションコンポーネントがJSXなどの描画の役割を担っており、これも言葉のイメージと一致する。
コンテナがプレゼンテーションに、表示させたいデータを提供する。

Reactだと、自然にこのようなコンポーネント関係になるのかもしれない。

そして、現在（2022-05-29）の主流であるHooksを利用すると、コンテナコンポーネントをなくして、Hooksをプレゼンテーションコンポーネント内に配置できる、とのこと。
Hooksを使うと、もともとの関心の分離という目的は達成できるため、コンテナ・プレゼンテーションパターンは不要になってくる。

