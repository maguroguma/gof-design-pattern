# Mediatorパターン

- Mediatorは「仲裁人、調停者」を意味する。
- 「多数のオブジェクトの間の調整を行いながら処理をすすめる必要がある場合に利用すると威力を発揮する」パターン。
- TECHSCOREさんの以下の例は確かにあるあるかもと思った。

> Mediatorパターンは、入力インターフェースなどに利用することができるでしょう。
> 例えば、「複雑に絡み合ったある条件を満たさなければ「有効」にならないボタン」なんてものを作成したいときは
> Mediatorパターンを思い出すべきですね。

以下は実装の詳細の説明など。

- `needsAdvice` は、自身が持っている `mediator` の `consultation` メソッドを呼ぶ。
  - つまり、委譲（コンポジション）の形。
- 必ずしも、それぞれの具象クラスに `mediator, colleague` のためのフィールドを持たせなくても、各メソッドに引数として持たせてもよいのかもしれない。
  - ただし、いずれにしても、依然として相互に依存は確実に存在し続ける。
- 「複数のものの状態の一元管理」っぽくも見えるので、抽象化せずによく使われている形式なのかもしれない。
  - 逆に、抽象化して再利用できるケースは余り思い浮かばない。。

## クラス図

![](../images/mediator.jpg)

## [フロントエンドのデザインパターン: メディエータ・ミドルウェアパターン](https://zenn.dev/morinokami/books/learning-patterns-1/viewer/mediator-pattern)

複数コンポーネント間の統治という、この記事の例の方がわかりやすいと思った。

> 中央のメディエータオブジェクトを介して、コンポーネント間のやり取りを処理する。

> 各オブジェクトが他のオブジェクトと直接やり取りし、 **多対多の関係となる代わりに、オブジェクトのリクエストをメディエータが処理するよう** にします。
> メディエータはこのリクエストを処理し、必要なところへ送ります。

**スター型トポロジが形成されるイメージを持ちたい。**

> メディエータパターンのわかりやすい例としてはチャットルームがあります。
> チャットルームのユーザは、お互いに直接話すことはありません。
> その代わり、チャットルームサーバがメディエータとしてユーザを仲介します。

### 実装してみて

- わかり易い例だったので、まずは「ユーザオブジェクトがメディエータオブジェクトをhasする（コンポジション）」というパターンになれたい。
  - 多対多を多対1にするメリットは大きいので、今後お世話になりそう

